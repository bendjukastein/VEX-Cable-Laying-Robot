#pragma config(Sensor, in1,    IR_FAR_1,       sensorReflection)
#pragma config(Sensor, in6,    IR_FAR_LONG,    sensorReflection)
#pragma config(Sensor, in8,    IR_FAR_2,       sensorReflection)
#pragma config(Sensor, dgtl1,  button1,        sensorTouch)
#pragma config(Sensor, dgtl2,  button2,        sensorTouch)
#pragma config(Sensor, dgtl3,  motor1_quad,    sensorQuadEncoder)
#pragma config(Sensor, dgtl10, LED,            sensorLEDtoVCC)
#pragma config(Sensor, dgtl11, sonar,          sensorSONAR_cm)
#pragma config(Motor,  port1,           motor3,        tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           motor2,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           motor1,        tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//



/*
Name: Ben Djukastein,Brynna Clarke, Ethan Macmillan
*Note* Some code inspired by my professor Dr. Michael Mcguire, and used with his permission. monitorlightleft(), monitorlightright(), andmonitorlightfar(), were all based off a function he provided called monitorlight().
The monitorinput() function is fully Dr. Michael Mcguireâ€™s work as well.
Group: 139
Lab Section:B09
Date: Mar 14th 2019
*/

/*
Tasks:

a)Turn  your  robot  towards  the  target  object
b) move accurately towards it
c) connect the cable to the beacon
d) do not get entangled in the cable

*/

//motor1 is right side.
//motor2 is left side
//motor 3 is activation mechanism
//IR_FAR_1 is left side IR sensor
//IR FAR_2 is right side IR sensor
//IR_FAR_LONG is the central long range IR sensor

//*********************WHEN YOU FINISH EACH EXERCISE, INCREMENT THIS VALUE***************************************
#define EXERCISE_NUMBER 	3


//Global Variables

bool button1_pushed; //flag to store button1 input
bool button2_pushed; //flag to store button2 input
const   int OFF = 0;// integer used to turn off the LEDs
const   int ON  = 1;//integer used to turn on the LEDs
int Motor_Speed = 40;//Controls strength of motor.
int adjustment_time = 0;//Records time taken to travel from left IR max to right IR max direction when spinning.
int CONNECTION_DISTANCE = 5; //Maximum distance (cm) that the robot can be from the beacon when connecting the cable
int HIGH_IR = 800; // minimum IR to be considered facing the beacon, while near the beacon

int LOW_IR = 200; // minimum IR to be considered facing the beacon while advancing

int monitorlightleft()
{
	static int minLevelIR1 = 2800;	// Minimum light level seen by IR sensor 1(InfraCollector)
	static int maxLevelIR1 = 0;        	// Maximum light level seen by IR sensor 1
	static int diffLevelIR1 = 0;    	// Difference between maximum and minimum seen in last 0.1 seconds

	int lightLevel1 = SensorValue[IR_FAR_1];

	// Check when 100 msecs elapse.
	if ( time1[T1] > 150 )  {

    	// 100 msecs have elapsed.  Computing delta of light level.
    	diffLevelIR1 = maxLevelIR1 - minLevelIR1;

    	// Reset calculation for next 100 msecs.
    	maxLevelIR1 = 0;
    	minLevelIR1 = 2800;
    	clearTimer(T1);

    	} else {

    	// Check for new minimum/maximum light levels.
    	if ( lightLevel1 < minLevelIR1 ) {
        	minLevelIR1 = lightLevel1;
        	} else if ( lightLevel1 > maxLevelIR1 ) {
        	maxLevelIR1 = lightLevel1;
    	}
	}

	return(diffLevelIR1);
}

int monitorlightfar()
{
	static int minLevelIR3 = 1200;	// Minimum light level seen by IR sensor
	static int maxLevelIR3 = 0;        	// Maximum light level seen by IR sensor 1
	static int diffLevelIR3 = 0;    	// Difference between maximum and minimum seen in last 0.1 seconds

	int lightLevel3 = SensorValue[IR_FAR_LONG];

	// Check when 100 msecs elapse.
	if ( time1[T3] > 150 )  {

    	// 100 msecs have elapsed.  Computing delta of light level.
    	diffLevelIR3 = maxLevelIR3 - minLevelIR3;

    	// Reset calculation for next 100 msecs.
    	maxLevelIR3 = 0;
    	minLevelIR3 = 1200;
    	clearTimer(T3);

    	} else {

    	// Check for new minimum/maximum light levels.
    	if ( lightLevel3 < minLevelIR3 ) {
        	minLevelIR3 = lightLevel3;
        	} else if ( lightLevel3 > maxLevelIR3 ) {
        	maxLevelIR3 = lightLevel3;
    	}
	}

	return(diffLevelIR3);
}


int monitorlightright()
{// this function monitors the intensity of IR light from the right-hand beacon.
	static int minLevelIR2 = 2800;// Minimum light level seen by IR sensor 1(InfraCollector)
	static int maxLevelIR2 = 0;        	// Maximum light level seen by IR sensor 1
	static int diffLevelIR2 = 0;    	// Difference between maximum and minimum seen in last 0.1 seconds

	int lightLevel2 = SensorValue[IR_FAR_2];

	// Check when 100 msecs elapse.
	if ( time1[T4] > 100 )  {

    	// 100 msecs have elapsed.  Computing delta of light level.
    	diffLevelIR2 = maxLevelIR2 - minLevelIR2;

    	// Reset calculation for next 100 msecs.
    	maxLevelIR2 = 0;
    	minLevelIR2 = 2800;
    	clearTimer(T4);

    	} else {

    	// Check for new minimum/maximum light levels.
    	if ( lightLevel2 < minLevelIR2 ) {
        	minLevelIR2 = lightLevel2;
        	} else if ( lightLevel2 > maxLevelIR2 ) {
        	maxLevelIR2 = lightLevel2;
    	}
	}

	return(diffLevelIR2);
}









void monitorInput()
{
	if(SensorValue(button1) && !button1_pushed)
	{
    	button1_pushed = true;
	}

	if(SensorValue(button2) && !button2_pushed)
	{
    	button2_pushed = true;
	}
}



//Exercise 3 should be: Turning the robot to face the beacon.(aka SEARCHING)

void exercise_3()
{
	// Define tag for enumerated type for exercise 1
	enum T_exercise3_state {
    	MOTOR_STOP = 0,
    	SEARCHING,
    	SEARCHING_FAR,
    	ADJUSTING_LEFT,
    	CORRECTING,
    	ADVANCING,
    	ADVANCING_LEFT,
    	ADVANCING_RIGHT,
    	CORRECT_LOCATION,
    	CELEBRATE,
	};



	T_exercise3_state exercise3_state = MOTOR_STOP;

	while(true)
	{
    	// Switch the states.
    	switch(exercise3_state) {


case MOTOR_STOP:
monitorInput();
    	// Turn motors off.
        	motor[motor1] = OFF;
        	motor[motor2] = OFF;
        	motor[motor3] = ON;// this motor is reversed, so ON stops it.
        	SensorValue(LED)= ON;//LEDS are turned on when set to 0, so initializing to 1 "ON"
        	if ( button1_pushed ) {
            	// If button1 pushed, change to the SEARCHING state.
        	clearTimer(T2);
            	exercise3_state = SEARCHING;
            	// Clear flag to indicate button 1 processed.
            	button1_pushed = false;
        	}//if
            	break;



case SEARCHING:

            	motor[motor1] = (-1 * Motor_Speed);
            	motor[motor2] = Motor_Speed;

            	if (monitorlightright() >= HIGH_IR){
            	//this value represents the difference between ambient light and the blinking IR, returns a value every .1 seconds
                	//   if condition is met, robot should begin ADVANCING;   since the IR coming in from one side of the front is different than the other.

                	clearTimer(T3);
            	exercise3_state = ADJUSTING_LEFT;
            	}//if IR HIGH
      	}//if time low
     	 
      	if(time1[T2] > 10000){
     		 exercise3_state = SEARCHING_FAR;
  	}//if time high
     	 
        	break;
       	 
       	 
       	 
       	 
case SEARCHING_FAR:

   	motor[motor1] = (-1 * Motor_Speed);
   	motor[motor2] = Motor_Speed;
  	 
   			 if (monitorlightfar() >= 200){
   	//if the long ranged IR sensor detects that it is facing the sensor, change state.
     	clearTimer(T3);
    	exercise3_state = ADVANCING;
    	}//if

    	break;
       	 
       	 
       	 
       	 

case ADJUSTING_LEFT:

if(monitorlightleft() >= 800){

                            	adjustment_time = time1(T3);
                            	clearTimer(T2);
                            	exercise3_state = CORRECTING;
                    	}
                            	//this adjusts the robot until it moves to a position where the leftside sensor is detecting the beacon
            	motor[motor2] = (-1 * Motor_Speed);
            	motor[motor1] = Motor_Speed;


break;


case CORRECTING:


                        	while(time1(T2) < adjustment_time*0.6){
                        	//this moves to the centre of the locations where the left and right IRs started to detect the beacon, ideally centring.
                        	motor[motor1] = (-1 * Motor_Speed);
            	motor[motor2] = Motor_Speed;
                    	}

                        	exercise3_state = ADVANCING;
                        	break;



case ADVANCING:
//If robot is facing the beacon, but too far to connect, move forward.
        	if(monitorlightleft() +LOW_IR < monitorlightright())
        	{
             	exercise3_state = ADVANCING_LEFT;
        	}

        	if(monitorlightleft() > monitorlightright() + LOW_IR)
        	{
            	exercise3_state = ADVANCING_RIGHT;
        	}

        	if(abs(monitorlightleft() - monitorlightright()) <= LOW_IR)
    	{
    		
    		if(monitorlightleft() < 2700)
	{
    motor[motor1] = -Motor_Speed;
    motor[motor2] = -Motor_Speed;
	}//advance quickly if far from beacon
	else
		{
			motor[motor1] = -Motor_Speed/2;
    	motor[motor2] = -Motor_Speed/2;
	}//advance more slowly if close to beacon
    	
    	
    	
            	
            	if (SensorValue[sonar] <= CONNECTION_DISTANCE)
            	{
                	exercise3_state = CORRECT_LOCATION;
            	}
      	if (monitorlightfar()<= 500)
        	{
        		exercise3_state = SEARCHING;
        	}

            }//if advancing forward
    	

    	//  END OF ADVANCEMENT, either hit a wall or hit the beacon
        	break;



case ADVANCING_LEFT:

if(monitorlightleft() < 2700)
	{
		motor[motor1] = Motor_Speed/2;
   	motor[motor2] = -1*(Motor_Speed);
	}//advance quickly if far from beacon
	else
		{
			motor[motor1] = Motor_Speed/4;
   	motor[motor2] = -1*(Motor_Speed/2);
	}//advance more slowly if close to beacon
	
             	
             	if (SensorValue[sonar] <= CONNECTION_DISTANCE)
     	{
            	exercise3_state = CORRECT_LOCATION;
    	}//if

        	

        	if(monitorlightleft() > monitorlightright() + LOW_IR)
        	{
            	exercise3_state = ADVANCING_RIGHT;
        	}//if

        	if(abs(monitorlightleft() - monitorlightright()) <= LOW_IR)
        	{
            	exercise3_state = ADVANCING;
        	}//if

if (monitorlightfar()<= 500)
        	{
        		exercise3_state = SEARCHING;
        	}
    	//  END OF ADVANCEMENT, or hit the beacon
        	break;

case ADVANCING_RIGHT:

//
if(monitorlightright() < 2700)
	{
		motor[motor1] = -1*(Motor_Speed);
    motor[motor2] = Motor_Speed/2;
	}//advance quickly if far from beacon
	else
		{
		motor[motor1] = -1*(Motor_Speed)/2;
    motor[motor2] = Motor_Speed/4;
	}//advance more slowly if close to beacon
             	
             	if (SensorValue[sonar] <= CONNECTION_DISTANCE)
             	{
                	exercise3_state = CORRECT_LOCATION;
            	}//if

        

        	if(monitorlightleft() +LOW_IR < monitorlightright())
        	{
             	exercise3_state = ADVANCING_LEFT;
        	}//if

        	if(abs(monitorlightleft() - monitorlightright()) <= LOW_IR)
        	{
            	exercise3_state = ADVANCING;
        	}

        		if (monitorlightright()<= 400)
        	{
        		exercise3_state = SEARCHING;
        	}

    	//  END OF ADVANCEMENT, either hit a wall or hit the beacon
        	break;






case CORRECT_LOCATION://engages cable connection mechanism

SensorValue(LED)= OFF; // turn on the LED to signal task success, "OFF" sets LED to 0, which provides signal power
// Turn motors off.

    	motor[motor1] = OFF;
    	motor[motor2] = OFF;

    	clearTimer(T1);  //  robot shuffles right slightly to align load with beacon.
    	while(time1[T1] < 1000){
            	motor[motor1] =25;
            	motor[motor2] = -25;
            	button1_pushed = false;
	}//while
            	motor[motor1] = OFF;
            	motor[motor2] = OFF;

    	clearTimer(T1);  //  release mechanism moter (motor3) go forward to push cable off, and allow spool to drop
    	while(time1[T1] < 800){
            	motor[motor3] = 25;
            	button1_pushed = false;
	}//while
    	clearTimer(T1); // wait for half a second to allow the spool to fall off
    	while(time1[T1] < 400){
            	motor[motor3] = 0;
            	button1_pushed = false;
	}//while
    	clearTimer(T1);   // revert back to initial position to allow for simpler retrials. (reverses)
    	while(time1[T1] < 500){
            	motor[motor3] = -25;
            	button1_pushed = false;
	}
        	exercise3_state = CELEBRATE;

        	break;


break;

case CELEBRATE:
//identical to MOTOR_STOP, except the success LED stays on.

			motor[motor1] = OFF;
    	motor[motor2] = OFF;
    	motor[motor3] = OFF;
    	SensorValue(LED)= OFF;
    	//sleep(3000);
    	//SensorValue(LED)= ON;
//this was used to make sure we did not leave the light on for too long.

    	
    	if ( button1_pushed ) {
            	// If button1 pushed, go back to the MOTOR_STOP state.
        	clearTimer(T2);
            	exercise3_state = MOTOR_STOP;
            	// Clear flag to indicate button 1 processed.
            	button1_pushed = false;
        	}//if

break;

  	}//switch
	}//while
}//exercise 3







void exercise_4()
{
	// Define tag for enumerated type for exercise 4
	enum T_exercise4_state {
    	MOTOR_STOP = 0,
    	GOING_FORWARD,
	};

	// Declare variable to hold state, intialize to MOTOR_STOP state.
	T_exercise4_state exercise4_state = MOTOR_STOP;



	while(true)
	{
    	// Switch the states.
    	switch(exercise4_state) {

        	// Code for MOTOR_STOP state:
case MOTOR_STOP:
monitorInput();
    	// Turn motors off.
        	motor[motor1] = OFF;
        	motor[motor2] = OFF;
        	SensorValue(LED)= OFF;
        	if ( button1_pushed ) {
            	// If button1 pushed, change to the MOTOR_RUNNING state.
            	exercise4_state = GOING_FORWARD;
            	// Clear flag to indicate button 1 processed.
            	button1_pushed = false;
        	}//if
            	break;

case GOING_FORWARD:
        	// Turn LED on.
    	SensorValue[LED] = ON;
    	if(SensorValue[sonar] <= CONNECTION_DISTANCE){
        	//if any of the conditions fail (with some IR buffer room), turn off the LED, as the robot is either too close or not facing the beacon.
        	exercise4_state = MOTOR_STOP;
  	}

        	break;

    	default:
    	}//

	}//end while
}//exercise 4







task main()
{
	button1_pushed = button2_pushed = false;

	switch (EXERCISE_NUMBER)
	{
	case 3:
    	exercise_3(); //Actual entire connection function
    	break;
	case 4:
    	exercise_4(); //Unused in final draft, used for testing independent parts
    	break;
	default: //should never get here.
	} // end switch
} // end main

