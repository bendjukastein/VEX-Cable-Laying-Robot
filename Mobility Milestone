#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  button1,        sensorTouch)
#pragma config(Sensor, dgtl2,  button2,        sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           motor3,        tmotorVex393_HBridge, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port2,           motor2,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           motor1,        tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
Name: Ben Djukastein,Brynna Clarke, Ethan Macmillan

Group: kit 139
Lab Section:B09
Date: Feb 10th 2019
*/

//motor1 is right side.
//motor2 is left side
// motor 3 is top/ release mechanism

// WHEN YOU FINISH EACH EXERCISE, INCREMENT THIS VALUE
#define EXERCISE_NUMBER 	2

bool button1_pushed; //flag to store button1 input
bool button2_pushed; //flag to store button2 input


/* monitorInput()
*
*  Used to flag button inputs
*       - this avoids errors caused by program recognizing input, taking action, and
*         reading input again before button is released
*/
void monitorInput()
{
	if(SensorValue(button1) && !button1_pushed)
	{
		button1_pushed = true;
	}

	if(SensorValue(button2) && !button2_pushed)
	{
		button2_pushed = true;
	}
}








void exercise_1()
{
	// Define tag for enumerated type for exercise 1
	enum T_exercise1_state {
		MOTOR_STOP = 0,
		MOTOR_RUNNING,
		MOTOR_TURNING
	};

	// Declare variable to hold state, intialize to MOTOR_STOP state.
	T_exercise1_state exercise1_state = MOTOR_STOP;
	int Motor_Speed = 50;//                                       CHANGE THIS VALUE dependent on  torque required.


	while(true)
	{
		// This function updates the button1_pushed and button2_pushed flags.
		monitorInput();

		// Switch the states.
		switch(exercise1_state) {

			// Code for MOTOR_STOP state:
		case MOTOR_STOP:
			// Turn motor off.
			motor[motor1] = 0;
			motor[motor2] = 0;
			if ( button1_pushed ) {
				// If button1 pushed, change to the MOTOR_RUNNING state.
				exercise1_state = MOTOR_RUNNING;
				// Clear flag to indicate button 1 processed.
				button1_pushed = false;
			}
			if ( button2_pushed ) {
				// If button1 pushed, change to the MOTOR_RUNNING state.
				exercise1_state = MOTOR_TURNING;
				// Clear flag to indicate button 1 processed.
				button2_pushed = false;
			}
			break;

		case MOTOR_TURNING:
			// Turn motor on.
			clearTimer(T1);

		while(time1[T1] < 1501){

				motor[motor1] = Motor_Speed;
				motor[motor2] = Motor_Speed;
				button1_pushed = false;
				button2_pushed = false;
	}
			exercise1_state = MOTOR_STOP;
			break;

		case MOTOR_RUNNING:
			//turn one motor forward, and the other motor backward equally.
			clearTimer(T1);
		while(time1[T1] < 3500){
				motor[motor1] = (-1 * Motor_Speed);
				motor[motor2] = Motor_Speed;
				button1_pushed = false;
				button2_pushed = false;
	}


			exercise1_state = MOTOR_STOP;
			break;

		default:

		}

	}//end while
}







void exercise_2()
{
	// Define tag for enumerated type for exercise 1
	enum T_exercise2_state {
		MOTOR_STOP = 0,
		MOTOR_RUNNING,
	};

	// Declare variable to hold state, intialize to MOTOR_STOP state.
	T_exercise2_state exercise2_state = MOTOR_STOP;
	int Motor_Speed = 50;//CHANGE THIS VALUE dependent on  torque required.


	while(true)
	{
		// This function updates the button1_pushed and button2_pushed flags.
		monitorInput();

		// Switch the states.
		switch(exercise2_state) {

			// Code for MOTOR_STOP state:
		case MOTOR_STOP:
			// Turn motor off.
			motor[motor3] = 0; //                            CHANGE THIS TO MOTOR 3
			if ( button1_pushed ) {
				// If button1 pushed, change to the MOTOR_RUNNING state.
				exercise2_state = MOTOR_RUNNING;
				// Clear flag to indicate button 1 processed.
				button1_pushed = false;
			}
			break;

		case MOTOR_RUNNING:
			// Turn motor on.
		clearTimer(T1);  //  go forward to push thing off, and allow spool to drop
		while(time1[T1] < 1500){
				motor[motor3] = 25;
				button1_pushed = false;
	}
		clearTimer(T1); // wait for half a second to allow the spool to fall off
		while(time1[T1] < 400){
				motor[motor3] = 0;
				button1_pushed = false;
	}
		clearTimer(T1);   // revert back to initial position to allow for simpler retrials. (reverses)
		while(time1[T1] < 730){
				motor[motor3] = -25;
				button1_pushed = false;
	}

			//                                   THIS TIME INTERVAL WILL CAUSE ISSUES IF TOO LARGE
			//motor[motor3] = -20; //make sure this is equivalent to the forward motion
			//sleep(1000);  // make this sleep time equal to above.
			exercise2_state = MOTOR_STOP;
			break;

		default:

		}

	}//end while
}

task main()
{
	button1_pushed = button2_pushed = false;

	switch (EXERCISE_NUMBER)
	{
	case 1:
		exercise_1();//This has the robot move forward 1 metre and turn 90 degrees at the touch of a button.
		break;
	case 2:
		exercise_2(); //This has the robot push the load ontothe beacon.
		break;
	default: //should never get here.
	} // end switch

}// end main
